---
title: "Funciones"
output:
  html_document:
    df_print: paged
  word_document: default
autor: Juan Manuel Moreno
---

# Funciones

Especialmente, cuando una compañía realiza procesos que serán llevados a producción, uno de los elementos más importantes es que, sus programas estén modularizados con **funciones**, de esta manera, se mejora la legibilidad del código, la velocidad, reusabilidad y aumenta la tolerancia a fallos del mismo.

En R para declarar una función se utiliza el comando **`function`**, como en cualquier lenguaje de programación, las funciones pueden recibir parámetros de **entrada** y parámetros de **salida**, se describirán algunos ejemplos para comprender estas dos metodologías.

En primer lugar, se realizará una función simple que reciba como parámetro de entrada un número y lo devuelva elevado al cubo. Para devolver cualquier valor de una función, será necesario utilizar la palabra reservada **return**.

```{r}
# Python

# def exp_test(numer):
#   result = number ** 3
#   return result
  
# Creamos la función
exp.test <- function(number){
  result <- number ^ 3
  return (result)
}
```


```{r}
# Llamamos a la función
a <- exp.test(number = 3)
a
```

También se puede simplificar
```{r}
# Creamos la función
exp.test <- function(number){
  return (number^3)
}
```

```{r}
# Llamamos a la función
a <- exp.test(number = 3)
a
```


Realizando una modificación en el ejemplo anterior, es posible codificarlo para que el programa reciba dos números y, devuelva como resultado, el primer número elevado al segundo.

```{r}
# Creamos la función
exp.test <- function(number, pow){
  result <- number ^ pow
  return (result)
}
```

```{r}
# Llamamos a la función
a <- exp.test(number = 3, pow = 4)
a
```
Args y Kwargs en R: https://www.geeksforgeeks.org/function-arguments-in-r-programming/

Si intentamos devolver más de un valor...
```{r}
# def my_function(a,b):
#   suma = a+b
#   resta = a+b
#   return suma, resta
  
my.funcion <- function(a, b){
  suma <- a + b
  resta <- a - b 
  return (suma, resta)
}

my.funcion(a=5, b=2)
```

```{r}
my.funcion <- function(a, b){
  
  outputs <- list()
  
  outputs$suma <- a + b
  outputs$resta <- a - b 
  
  
  return (outputs)
}

my.funcion(a=5, b=2)
```


Por lo general, R está preparado para devolver un sólo valor en una función, no obstante, si devolvemos una estructura de datos como por ejemplo, una lista, posteriormente, podremos acceder por separado a sus ítems.

En el siguiente ejemplo, se desarrollará una función que reciba como parámetro de entrada un vector y, devuelva su valor máximo y mínimo.

```{r}
min.max <- function(v){
  # Inicializamos una lista vacía.
  my.list <- list()
  
  my.list$min <- min(v)
  my.list$max <- max(v)
  
  return (my.list)
}
```


```{r}
results <- min.max(v = c(100, 20, 34, 8))
results
```


```{r}
results$min
results$max
```

### Ejercicio 1

Toma el siguiente vector
```{r}
vector <- sample(1:1000000, 100000, replace = F)
```

Define una funciones llamada `estadisticas()` que reciba como parámetro dicho vector y que devuelva la siguiente información:

* Longitud del vector.
* Valor mínimo del vector.
* Valor máximo del vector.
* Media del vector.
* Mediana del vector.
* Desviación estándar del vector.
* Suma del vector.
* Suma acumulada del vector

#### Solución
```{r}
# En clase.
estadisticas <- function(vector.param){
  
  # Lista de outputs
  outputs = list()
  
  # * Longitud del vector.
  outputs$longitu <- length(vector.param)
  
  # * Valor mínimo del vector.
  outputs$min <- min(vector.param)
  
  # * Valor máximo del vector.
  outputs$max <- max(vector.param)
  
  # * Media del vector.
  outputs$media <- mean(vector.param)  
  
  # * Mediana del vector.ç
  outputs$mediana <- median(vector.param)
  
  # * Desviación estándar del vector.
  outputs$std <- sd(vector.param)
  
  # * Suma del vector.
  outputs$suma <- sum(vector.param)
  
  # * Suma acumulada del vector
  outputs$sacumulada <- cumsum(vector.param)
  
  return (outputs)
}
```

```{r}
stats <- estadisticas(vector.param = vector)
stats$sacumulada
```


### Ejercicio 2

Define una función que recorra todas las columnas de un dataframe y, si encuentra un valor nulo lo reemplace por un valor pasado como parámetro, puedes tomar el siguiente dataframe como ejemplo:

```{r}
my.df <- data.frame("alumnos" = c("Jose", "María", "Ana", "Javier", "Natalia", "Jorge"),
                    "edad" = c(20, NA, NA, 25, 26, 24))
```

#### Solución
```{r}
# En clase.
```

# Funciones Apply
Existen una familia de funciones que sirven para automatizar una función sobre una secuencia de valores, de esta manera omitiendo el uso de bucles, estas funciones son todas derivadas de la función principal **`apply`**. Se mostrará un ejemplo de cada tipo de función:

* **`apply`**: Realiza una misma operación sobre los ejes, por ejemplo: Supongamos que se quiere obtener la suma de las columnas, la función apply recibirá como parámetros, los datos, la dirección ( filas o columnas) y la función a aplicar.
```{r}
m <- matrix(c(1:10), nrow = 5, ncol = 2)
m
```


```{r}
apply(m, 2, sum)
```

Del mismo modo funcionará en las filas.
```{r}
apply(m, 1, sum)
```

* **`lapply`**: Misma función que apply, pero su funcionamiento está optimizado en listas. El resultado, lo devuelve también como una lista.
```{r}
v   <- matrix(1:10, ncol = 2, nrow = 5)
v.2 <- matrix(5:14, ncol = 2, nrow = 5)

lista = list(v, v.2)
lista
```


```{r}
# Obtenemos la multiplicación
lapply(lista, FUN = prod)
```

* **`sapply`**: Recibe una lista, aplica una función y, devuelve un vector.
```{r}
sapply(lista, prod)
```

* **`tapply`**: Realiza una operación, en función de un vector de factores, operación aconsejable para dataframes.
```{r}
v.num <- c(10:20)
v.fact <- c("PAR", "IMPAR", "PAR", "IMPAR", "PAR", "IMPAR",
            "PAR", "IMPAR", "PAR", "IMPAR", "PAR")

tapply(v.num, v.fact, sqrt)
tapply(v.num, v.fact, sum)
```

### Ejercicio 3

Toma el dataset **mtcars** y, devuelve las medias de sus columnas

#### Solución
```{r}
# En clase
apply(mtcars, 2, mean)
```

### Ejercicio 4

Toma el dataset **iris** y, muestra la media de cada tipo de flor en función de la longitud del sépalo

#### Solución

```{r}
# En clase.
tapply(iris$Sepal.Length, iris$Species, mean)
```


### Ejercicio 5

Toma el dataset **iris** y, ordena todas las columnas del dataframe

#### Solución

```{r}
head(iris)
```

```{r}
# En clase.
apply(iris, 2, sort)
```

### Ejercicio 6

Toma el dataset **iris** y, muestra el rango (min, max) de todas sus columnas.

```{r}
# En clase.
apply(iris, 2, range)
```

# Funciones de conversión

Se ha visto en secciones anteriores que, R dispone de una amplia variedad de funciones ya predefinidas que nos ahorran trabajo a la hora de procesar datos, en este punto, se mostrarán algunas de ellas, es muy importante que, siempre que quiera realizarse un tipo de acción específica, se investigue si R ya posee una función propia, ya que estará optimizada y, por supuesto, nos ahorrará trabajo.

* **`is.character`**: Devuelve un booleano en función de si la variable es o no caracter.
```{r}
class("hola")
```
```{r}
class(5.90)
```
```{r}
class(FALSE)
```

```{r}
a <- "hola"
is.character(a)

b <- 5
is.character(b)
```

* **`is.factor`**: Devuelve un booleano en función de si la varible es o no categórica.
```{r}
a <- "hola"
b <- as.factor("hola")

is.factor(a)
is.factor(b)
```

* **`is.numeric`**: Devuelve un booleano en función de si la variable es numérica o no.
```{r}
a <- 5
b <- 3.0
c <- "a"

is.numeric(a)
is.numeric(b)
is.numeric(c)
```

* **`as.character`**: Transforma una variable categórica o numérica a carácter.
```{r}
a <- factor(c("UNO", "DOS"))
levels(a)
class(a)
```

```{r}
new.a <- as.character(a)
class(new.a)
```
```{r}
levels(new.a)
```

```{r}
as.character(3.23)
as.character(5)
```

* **`as.numeric`**: Transforma en variable numérica una variable categórica.
```{r}
a <- factor(c("POSITIVE", "NEGATIVE", "POSITIVE"))
levels(a)

as.numeric(a)
```

También es posible transformar en numérico cadenas de texto, si son explicitamente, números.
```{r}
as.numeric("58.45")
```

* **`as.factor`**: Permite transformar a factor un vector, ya se numérico o de caracteres. 
```{r}
a <- c(1,2,1,2)

b <- c("hola", "adios", "hola", "hola", "adios")

as.factor(a)
as.factor(b)
```

# Otras funciones

* **`table`**: Muestra la frecuencia de los valores únicos de una variable.
```{r}
table(b)
```


```{r}
table(a)
```

* **`unique`**: Muestra los valores únicos de una variable.
```{r}
y <- c(1, 2, 3, 5, 9, 1, 2, 3, 9, 0)

unique(y)
```

* **`set.seed`**: Recibe como parámetro un número entero, replica siempre el mismo resultado (muy recomendable cuando trabajamos con aleatorios)
```{r}
set.seed(777)

sample(1:10, replace=T)
sample(1:10, replace=T)
sample(1:10, replace=T)
```

```{r}
set.seed(1234)
rnorm(1:100)
```

* **`data.frame`**: Permite crear de cero un dataframe, a través de vectores o matrices.

```{r}
v <- matrix(1:40, nrow = 20, ncol = 2)
```

```{r}

df <- data.frame("ventas_q1" = v[ ,1], "ventas_q2" = v[ ,2],
                 "ventas_q3" = v[ ,1], "ventas_q4" = v[ ,2])

df

str(df)
names(df)
```






